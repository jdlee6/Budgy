=======================================
============CHANGES I MADE=============
=======================================
- bootstrapped nestjs/graphql app
- controller/service/module/resolver for user
- expense model
  1. define class
  2. define service file
  3. define expense repository file
  4. define expense resolver file
  5. create-expense.dto for expense.service

- user model
  1. create user repository file
  2. define create user dto
- create modules for user, expense and add to app.module

- update expense
  service
  resolver 
  repository

- update, delete functionality for expense
  - resolver
  - service

- update, delete functionality for user
  - learned about @InputType for any DTOs being used as args. to a func call
  - learned about @ObjectType for any DTOs that are being read

- read, delete, update functionalities for user and expense
  - service/repository methods
  - dto's for related
- output types for create/update user & expenses
      ** dto is usually related for defining the input types
      ** output types is usually related for defining the return object


* configure db connection - look at ormconfig.ts
* tweak npm command for migrations
  npm run typeorm migration:run - up functions
  npm run typeorm migration:revert - down functions
* had to configure the entities[] within app.module.ts

- create user with graphql playground
- createexpensemigration 
- create expense related to user
- figured out how to show expenses on query
  * needed to define a .findOne({ where: ..., relations: ... })
- create script to seed data

- change recurring to recurrence
- created_at, updated_at for user model
- created_at, updated_at, billing_date for expense model
- updated migration & seed file
- updated entities, resolvers, service file to handle new properties
-


- category entity
- established relationship between category and expense
  * 1 to Many, Many expense to 1 cateogry
- category.resolver
- category.service
- category repository
- dto for create category/update category
- category module
- migration for cateogries
- seed data for categories
- categories for user model
- category for expense model

1. user created
2. category w/ userid created
3. expense w/ categoryid created

* user can see both expenses and categories


List of available functions:
GET users [x]
GET users/<:id>/expenses [x]
POST users {:newUserInput} [x]
PUT users {:updateUserInput}

GET category
POST category {:newCategoryInput}
PUT category {:updateCategoryInput}

GET expense
POST expense {:newExpenseInput}
PUT expense {:updateExpenseInput}

=======================================
==============IN PROGRESS==============
=======================================
- credentials in env variables (for db)

- fix expensesByCategoryId logic


- start budget model

- logic for handling every day of the month?


- start frontend


=======================================
=================TO DO=================
=======================================
- remove unnecessary dependencies from package.json
- remove .env for now

- design pattern:
  1. class define fields/columns
  2. define service file
  3. define repository file
  4. define dto to be used 
  5. define resolver for graphql 

  resolver -> calls service methods -> calls repo methods

  Create your TypeOrm entity as usual, let's say UserEntity (user.entity.ts file)
  Create a UserRepository class (user.repository.ts file)
  Create a UserService class as usual (user.service.ts file)
  Import the UserRepository into your UserService
  Update UserModule in order to provide the UserRepository and needed UserEntity


** BACKEND
  1. Expense model
    - CRUD
  2. Budget model
    - CRUD
  3. Category model
    - CRUD
  4. User model
    - CRUD

  Endpoints:
    1. List users 
    2. Create user
    3. Delete user by user id
    4. Update user by user id

    1. List all expenses by user id
    2. Delete expense by expense id
    3. Create expense by expense id
    4. Update expense by expense id

    1. List current budgets by user id & category id
    2. Delete budget by budget id
    3. Create budget by user id & category id
    4. Update budget by budget id

    1. List all categories by user id
    2. Delete category by category id
      * if budget related -> cascade deletion
    3. Create category with user id
    4. Update category by category id
  
